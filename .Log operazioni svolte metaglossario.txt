cd "C:\Users\Tommaso\Django rest framework\Udemy Django\"

conda activate met5

django-admin startproject Metaglossario_Gestisco



cd "C:\Users\Tommaso\Django rest framework\Udemy Django\Metaglossario_Gestisco"

Inizializzare git al version control

git init

vs studio si tinge di verde e fa comparire master in git bash, che significa che siamo nel ramo master della nostra git repository

git add .
aggiunge tutto alla nostra repository

git commit -m "initial commit"

ora heroku

shh keys skippate

crea app metaglossario_gestisco  manualmente su heroku

heroku git:remote -a metaglossario-gestisco

#è il nome dell'app creata su heroku
gli sto dicendo che le cose le voglio caricare lì e non su un altra app

decoupling della secret key:

Heroku > app metaglossario > settings > reveal config vars > key=SECRET_KEY , Value =nv5f(pbo#92(e24l#)oqgbx2sjv6*7_kp)u8uswjmyg$mju(r&


KEY=SECRET_KEY

gunicorn, python-decouple e django-heroku già installati da prima

aggiungi import django_heroku in settings.py
from decouple import config
import dj_database_url


dj_database_url
stiamo importando n database postgres da herku e ci sono coinvolti i settings le password username url ecc
quelli cambiano in heroku automanticamente, non posso averceli hard coded

in settings.py alla fine aggiungo
django_heroku.settings(locals())


ora il decoupling della secret key

SECRET_KEY = config("SECRET_KEY")

creo un file .env in cui mi salvo la secret key
SECRET_KEY = 'codicedellachiave'

ora devo dire a git di ignorare quel file, quindi un .gitignore file
i files e cartelle che iniziano con . sono nascoste
nel gitignore file scrivo l'elenco di files . che devono essere ignorati nell'upload, ossia il mio .env

whitenoise thing:
creo cartella static e ci metto dentro un file __init__.py per ora vuoto

ora devo specificare la directory degli static files (in settings)
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static')
]
STATICSTORAGE = "Whitenoise.storage.CompressedManifestStaticFilesStorage"

ora il whitenoise vero e proprio, dentro le installed apps di settings.py
'whitenoise.middleware.WhiteNoiseMiddleware',


procfile

nella directory principale creo un file Procfile senza estensione e ci scrivo dentro
web: gunicorn Metaglossario_Gestisco.wsgi
devi metterci la stessa cosa che trovi in wsgi.py : WSGI config for Metaglossario_Gestisco project.


il procfile mi indica che server viene usato (gunicorn)
se ho fatto bene, il Procfile prende la icona di heroku in vs code

requirements

pip freeze > requirements.txt
devo farlo ogni volta che installo un nuovo modulo, altrimenti heroku potrebbe dirmi che ha dei problemi e indica il collectstatics,
e spesso mi dice anche che non può trovare un modulo, quel modulo va inserito dentor requirements.txt
Nota che requirements prende i moduli installati in generale in python.

git add .
git commit -m "aggiunta app"
git push heroku master


Implementare il database
crea il superuser, ma prima devo fare migrate makemigrate

python manage.py createsuperuser

tommaso
tommaso.sansone@mail.polimi.ti
password


push del codice su heroku
git add .
git commit -m "second commit"
git push heroku master

in questo modo su heroku appare un database postgres che è psycopg2


Nota: ho pushato su heroku e non ho ancora il database

il comando per la diagnostica di cio che non funziona su heroku è 
heroku logs


push del codice su github

github > menu in alto a destra > your repositories > new repository > 
Nome: Metaglossario-Gestisco
<!> non creare readme se no poi fa conflitto e devo usare git pull !!
gitingnore: lascia none

git remote add origin https://github.com/tommasosansone91/Metaglossario-Gestisco.git
git push -u origin master

creo l'app (quella che avrà views, models, urls)
python manage.py startapp app_metaglossario




costruisco il database:
il mio postgres database (psycopg2) è già installato tra gli add ons di heroku
heroku > metaglossario-gestisco > resources > add ons
e l'url del database è stato generato, con al sintassi dell'ultima volta

se vado su post gres database negli addons e ci clicco apre una finestra di dialogo del database corrente
datastores > postgres ...id
se vado sotto settings mi elenca user, password host, ecc
è di questi che si prende cura il dj_database_url


ora se cerco di entrare nell admin dall'app di heroku non va bene il superuser di prima e mi da errore giallo di django
perche prima l'avevo creato in locale, quindi era stato immagazzinato nel database locale, ossia sqlite3,
ora invece devo crearne uno online dove verrà immagazzinato nel postgres database.


heroku run python manage.py migrate

changes applicate

heroku run python manage.py makemigrations
no cambiamenti (ovvio, non c'è il modello!)

esattamente come era avvenuto in locale

heroku run python manage.py createsuperuser

H_admin
tommaso.sansone@mail.polimi.it
password

i due superuser sonbo ancora distinti perchè non ho eseguito l'accoppiamento



 ACCOPPIAMENTO
***************

ora vado di nuovo in datastores di psotgres > settings > db credentials > database_uri
copio uri
la incollo nel default di databases in settings.py, sotto DATABASES

DATABASES['default']=dj_database_url.config(default='postgres://zogpunyhfdizcj:e4e8bbb8ef02572179d0ccdc1a146d4f2eba03e587525349bb4436a80b87f4ec@ec2-46-51-190-87.eu-west-1.compute.amazonaws.com:5432/dfibp7p1uu70v7')

#postgres://user:password@host:porta/database_name
incollare la uri del db in settings.py ci permette che quando runno il server localmente in realtà si connette al cloud di heroku
il locale e il cloud sono sincronizzati

se modifico il database in locale verrà modificato anche in cloud

da questo momento in poi sono condannato a collegarmi col tethering del telefno per runnare il server,
anche in locale, perchè grazie alla chiave si collega in remoto,
posso commentare quella liena per fermare questo effetto

Ma attenzione , perchè la chiave uri che ho incollato per fare la sincronizzazione
cambia day by day su heroku,
quindi non la posso hardcodificare, come ho fatto adesso.

quando la chaive sarà scaduta, posso commentare quella linea e la desincronizzazione mi permette di andare avanti a codificare


COPIO DALLA APP GLOSSARIO TUTTI I FILES
*****************************************

faccio il copia aincolla a mano avendo cura di non sovrascrivere le linee identitarie tipo password ecc
in particolare cambio i settings del database

copio e incollo la cartella templates da app_glossario ad app_metaglossario
copio e incollo il contenuto della cartella static nella directory principale dell metaglossario

Solo il contenuto del database non viene copiato



column app_metaglossario_glossary_entry.Lemma does not exist LINE 1: SELECT
mi dava errore sul glossario.hrml perche non avevo fatto makemigrations migrate dopo aver cambiato nomi alle componenti del modello

a quanto pare l'equivalente di

with open(path) as f:
        reader = csv.reader(f)      

        è

with open(path) as f:
        reader = pd.read_excel(f)
        

+++ ecco cosa c'era nel file Inizializzare

import pandas as pd


# Copia-incollati da
# https://stackoverflow.com/questions/26082128/improperlyconfigured-you-must-either-define-the-environment-variable-django-set/28297987#28297987
from django.conf import settings
settings.configure()

import django
django.setup() 

from app_metaglossario.models import glossary_entry
 


path=r"D:\Files Tommaso\Politecnico\Lavoro polimi\Algoritmi metaglossario Python\traformazioni di prova per il Metaglossario\dati_prova.xlsx"
 
with open(path) as f:
        reader = pd.read_excel(f)
        next(reader, None)  # skip the headers

        for row in reader:
                _, created = glossary_entry.objects.get_or_create(
                Lemma=row[0],
                Acronimo=row[1],
                Definizione=row[2],
                Ambito_riferimento=row[3],
                Autore_definizione=row[4],
                Posizione_definizione=row[5],
                Url_definizione=row[6],
                Titolo_documento_fonte=row[7],
                Autore_documento_fonte=row[8],
                Host_documento_fonte=row[9],
                Url_documento_fonte=row[10],
                Commento_entry=row[11],
                Data_inserimento_entry=row[12],
                Id_statico_entry=row[13],
                )
            # creates a tuple of the new object or
            # current object and a boolean of if it was created

+++++

la seconda versione ho fatto



# myapp/management/commands/import_csv.py
from django.core.management.base import BaseCommand, CommandError
import csv


# il path mi arriva da fuori come input da command line

csv_file=r"D:\Files Tommaso\Politecnico\Lavoro polimi\Algoritmi metaglossario Python\traformazioni di prova per il Metaglossario\dati_prova.csv"

class Command(BaseCommand):

    def add_arguments(self, parser):
        parser.add_argument('csv_file', nargs='+', type=str)

    def handle(self, *args, **options):
        for csv_file in options['csv_file']:
            dataReader = csv.reader(open(csv_file), delimiter=',', quotechar='"')
            for row in dataReader:
                glo=glossary_entry()
                glo.Lemma=row[0],
                Acronimo=row[1],
                Definizione=row[2],
                Ambito_riferimento=row[3],
                Autore_definizione=row[4],
                Posizione_definizione=row[5],
                Url_definizione=row[6],
                Titolo_documento_fonte=row[7],
                Autore_documento_fonte=row[8],
                Host_documento_fonte=row[9],
                Url_documento_fonte=row[10],
                Commento_entry=row[11],
                Data_inserimento_entry=row[12],
                Id_statico_entry=row[13],
                
                # etc...
                self.stdout.write(
                    'Created glossary entry'
                #     'Created glossary entry {} {}'.format(emp.Lemma, emp.Id_statico_entry)
                )

# You would then call this with:
# ./manage.py import_csv --csvfile "/home/<name>/webapps/<name2>/employees.csv"


#       python ./manage.py load_glossary csv_file "D:\Files Tommaso\Politecnico\Lavoro polimi\Algoritmi metaglossario Python\traformazioni di prova per il Metaglossario\dati_prova.csv"


++++++++


conda:

pip install django import-export

settings.py:

    INSTALLED_APPS = [
        'import_export',

admin.py:

from django.contrib import admin
from .models import glossary_entry 

from import_export import resources
from import_export.admin import ImportExportModelAdmin


class glossary_entry_resource(resources.ModelResource):
    class Meta:
        model=glossary_entry

class glossary_entry_Admin(ImportExportModelAdmin, admin.ModelAdmin):
    #resource_class = glossary_entry_resource
    pass


# Register your models here.
admin.site.register(glossary_entry, glossary_entry_Admin)

****

l'importazione da CSV è fallimentare, per importare dati usa i files xlsx

***

                        <p>
                        {% if entry.Url_definizione and entry.Url_definizione != "MISSING"  %}  
                            <a href="{{ entry.Url_definizione }}" Target= "_blank" class="btn btn-primary">Definizione</a> &nbsp                     
                        {% endif %}
                        </p>
                        
                        
                        <p>               
                        {% if entry.Url_documento_fonte and entry.Url_documento_fonte != "MISSING" %}  
                            <a href="{{ entry.Url_documento_fonte }}" Target= "_blank" class="btn btn-primary">Documento fonte</a> &nbsp                   
                        {% endif %}                                  
                        </p>

Ne faccio a meno perchè è problematico. meglio eliminare i missing prima di inserire i fogli. 
Il database di django è molto meglio per gestire i dati mancanti piuttosto che dargli un nome ap priori e fare mille speculazioni su cosa fare

oscurati per praticità i pulsanti url


l'errore a questa linea
 <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

è colpa di un url tag chiuso male in seguito

href="{% url 'home' %}"
va a prendere l'url mappato e riferito al template home, appellativo di home.html

href={% static "css/searchbar_style.css" %}
va a prendere il file al percorso inicato, nella cartella static, 
appellativo che ho dato alla cartella static(il nome dato a stati è specificato in settings.py)

ho cambiato il form della terminologia in modo da nascondere la data

        <div class="form-group">
              <!-- <label for="glossary_entry_input_13">Data di inserimento della terminologia</label>
              <small id="inputHelp" class="form-text text-muted">Compilare solo se è nota la data di pubblicazione del documento fonte, altrimenti inserire la data di oggi.</small>-->
               <input name="Data_inserimento_entry" type="hidden" class="form-control" id="date_to_turn_into_toda">              
        </div>

ma rimane il javascript

<script type="text/javascript" src={% static "js/get_today_date.js" %}></script>
<script> get_today_date() </script> 

fare le ombre in css
  .form-group input:hover{
    
    /* border-color: red; */
    box-shadow: 0 0 10px #ced4da;
    

    
  }

  