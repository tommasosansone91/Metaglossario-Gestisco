cd "C:\Users\Tommaso\Django rest framework\Udemy Django\"

conda activate met5

django-admin startproject Metaglossario_Gestisco



cd "C:\Users\Tommaso\Django rest framework\Udemy Django\Metaglossario_Gestisco"

Inizializzare git al version control

git init

vs studio si tinge di verde e fa comparire master in git bash, che significa che siamo nel ramo master della nostra git repository

git add .
aggiunge tutto alla nostra repository

git commit -m "initial commit"

ora heroku

shh keys skippate

crea app metaglossario_gestisco  manualmente su heroku

heroku git:remote -a metaglossario-gestisco

#è il nome dell'app creata su heroku
gli sto dicendo che le cose le voglio caricare lì e non su un altra app

decoupling della secret key:

Heroku > app metaglossario > settings > reveal config vars > key=SECRET_KEY , Value =nv5f(pbo#92(e24l#)oqgbx2sjv6*7_kp)u8uswjmyg$mju(r&


KEY=SECRET_KEY

gunicorn, python-decouple e django-heroku già installati da prima

aggiungi import django_heroku in settings.py
from decouple import config
import dj_database_url


dj_database_url
stiamo importando n database postgres da herku e ci sono coinvolti i settings le password username url ecc
quelli cambiano in heroku automanticamente, non posso averceli hard coded

in settings.py alla fine aggiungo
django_heroku.settings(locals())


ora il decoupling della secret key

SECRET_KEY = config("SECRET_KEY")

creo un file .env in cui mi salvo la secret key
SECRET_KEY = 'codicedellachiave'

ora devo dire a git di ignorare quel file, quindi un .gitignore file
i files e cartelle che iniziano con . sono nascoste
nel gitignore file scrivo l'elenco di files . che devono essere ignorati nell'upload, ossia il mio .env

whitenoise thing:
creo cartella static e ci metto dentro un file __init__.py per ora vuoto

ora devo specificare la directory degli static files (in settings)
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static')
]
STATICSTORAGE = "Whitenoise.storage.CompressedManifestStaticFilesStorage"

ora il whitenoise vero e proprio, dentro le installed apps di settings.py
'whitenoise.middleware.WhiteNoiseMiddleware',


procfile

nella directory principale creo un file Procfile senza estensione e ci scrivo dentro
web: gunicorn Metaglossario_Gestisco.wsgi
devi metterci la stessa cosa che trovi in wsgi.py : WSGI config for Metaglossario_Gestisco project.


il procfile mi indica che server viene usato (gunicorn)
se ho fatto bene, il Procfile prende la icona di heroku in vs code

requirements

pip freeze > requirements.txt
devo farlo ogni volta che installo un nuovo modulo, altrimenti heroku potrebbe dirmi che ha dei problemi e indica il collectstatics,
e spesso mi dice anche che non può trovare un modulo, quel modulo va inserito dentor requirements.txt
Nota che requirements prende i moduli installati in generale in python.

git add .
git commit -m "aggiunta app"
git push heroku master


Implementare il database
crea il superuser, ma prima devo fare migrate makemigrate

python manage.py createsuperuser

tommaso
tommaso.sansone@mail.polimi.ti
password


push del codice su heroku
git add .
git commit -m "second commit"
git push heroku master

in questo modo su heroku appare un database postgres che è psycopg2


Nota: ho pushato su heroku e non ho ancora il database

il comando per la diagnostica di cio che non funziona su heroku è 
heroku logs


push del codice su github

github > menu in alto a destra > your repositories > new repository > 
Nome: Metaglossario-Gestisco
<!> non creare readme se no poi fa conflitto e devo usare git pull !!
gitingnore: lascia none

git remote add origin https://github.com/tommasosansone91/Metaglossario-Gestisco.git
git push -u origin master

creo l'app (quella che avrà views, models, urls)
python manage.py startapp app_metaglossario




costruisco il database:
il mio postgres database (psycopg2) è già installato tra gli add ons di heroku
heroku > metaglossario-gestisco > resources > add ons
e l'url del database è stato generato, con al sintassi dell'ultima volta

se vado su post gres database negli addons e ci clicco apre una finestra di dialogo del database corrente
datastores > postgres ...id
se vado sotto settings mi elenca user, password host, ecc
è di questi che si prende cura il dj_database_url


ora se cerco di entrare nell admin dall'app di heroku non va bene il superuser di prima e mi da errore giallo di django
perche prima l'avevo creato in locale, quindi era stato immagazzinato nel database locale, ossia sqlite3,
ora invece devo crearne uno online dove verrà immagazzinato nel postgres database.


heroku run python manage.py migrate

changes applicate

heroku run python manage.py makemigrations
no cambiamenti (ovvio, non c'è il modello!)

esattamente come era avvenuto in locale

heroku run python manage.py createsuperuser

H_admin
tommaso.sansone@mail.polimi.it
password

i due superuser sonbo ancora distinti perchè non ho eseguito l'accoppiamento



 ACCOPPIAMENTO
***************

ora vado di nuovo in datastores di psotgres > settings > db credentials > database_uri
copio uri
la incollo nel default di databases in settings.py, sotto DATABASES

DATABASES['default']=dj_database_url.config(default='postgres://zogpunyhfdizcj:e4e8bbb8ef02572179d0ccdc1a146d4f2eba03e587525349bb4436a80b87f4ec@ec2-46-51-190-87.eu-west-1.compute.amazonaws.com:5432/dfibp7p1uu70v7')

#postgres://user:password@host:porta/database_name
incollare la uri del db in settings.py ci permette che quando runno il server localmente in realtà si connette al cloud di heroku
il locale e il cloud sono sincronizzati

se modifico il database in locale verrà modificato anche in cloud

da questo momento in poi sono condannato a collegarmi col tethering del telefno per runnare il server,
anche in locale, perchè grazie alla chiave si collega in remoto,
posso commentare quella liena per fermare questo effetto

Ma attenzione , perchè la chiave uri che ho incollato per fare la sincronizzazione
cambia day by day su heroku,
quindi non la posso hardcodificare, come ho fatto adesso.

quando la chaive sarà scaduta, posso commentare quella linea e la desincronizzazione mi permette di andare avanti a codificare


COPIO DALLA APP GLOSSARIO TUTTI I FILES
*****************************************

faccio il copia aincolla a mano avendo cura di non sovrascrivere le linee identitarie tipo password ecc
in particolare cambio i settings del database

copio e incollo la cartella templates da app_glossario ad app_metaglossario
copio e incollo il contenuto della cartella static nella directory principale dell metaglossario

Solo il contenuto del database non viene copiato



column app_metaglossario_glossary_entry.Lemma does not exist LINE 1: SELECT
mi dava errore sul glossario.hrml perche non avevo fatto makemigrations migrate dopo aver cambiato nomi alle componenti del modello

a quanto pare l'equivalente di

with open(path) as f:
        reader = csv.reader(f)      

        è

with open(path) as f:
        reader = pd.read_excel(f)
        

+++ ecco cosa c'era nel file Inizializzare

import pandas as pd


# Copia-incollati da
# https://stackoverflow.com/questions/26082128/improperlyconfigured-you-must-either-define-the-environment-variable-django-set/28297987#28297987
from django.conf import settings
settings.configure()

import django
django.setup() 

from app_metaglossario.models import glossary_entry
 


path=r"D:\Files Tommaso\Politecnico\Lavoro polimi\Algoritmi metaglossario Python\traformazioni di prova per il Metaglossario\dati_prova.xlsx"
 
with open(path) as f:
        reader = pd.read_excel(f)
        next(reader, None)  # skip the headers

        for row in reader:
                _, created = glossary_entry.objects.get_or_create(
                Lemma=row[0],
                Acronimo=row[1],
                Definizione=row[2],
                Ambito_riferimento=row[3],
                Autore_definizione=row[4],
                Posizione_definizione=row[5],
                Url_definizione=row[6],
                Titolo_documento_fonte=row[7],
                Autore_documento_fonte=row[8],
                Host_documento_fonte=row[9],
                Url_documento_fonte=row[10],
                Commento_entry=row[11],
                Data_inserimento_entry=row[12],
                Id_statico_entry=row[13],
                )
            # creates a tuple of the new object or
            # current object and a boolean of if it was created

+++++

la seconda versione ho fatto



# myapp/management/commands/import_csv.py
from django.core.management.base import BaseCommand, CommandError
import csv


# il path mi arriva da fuori come input da command line

csv_file=r"D:\Files Tommaso\Politecnico\Lavoro polimi\Algoritmi metaglossario Python\traformazioni di prova per il Metaglossario\dati_prova.csv"

class Command(BaseCommand):

    def add_arguments(self, parser):
        parser.add_argument('csv_file', nargs='+', type=str)

    def handle(self, *args, **options):
        for csv_file in options['csv_file']:
            dataReader = csv.reader(open(csv_file), delimiter=',', quotechar='"')
            for row in dataReader:
                glo=glossary_entry()
                glo.Lemma=row[0],
                Acronimo=row[1],
                Definizione=row[2],
                Ambito_riferimento=row[3],
                Autore_definizione=row[4],
                Posizione_definizione=row[5],
                Url_definizione=row[6],
                Titolo_documento_fonte=row[7],
                Autore_documento_fonte=row[8],
                Host_documento_fonte=row[9],
                Url_documento_fonte=row[10],
                Commento_entry=row[11],
                Data_inserimento_entry=row[12],
                Id_statico_entry=row[13],
                
                # etc...
                self.stdout.write(
                    'Created glossary entry'
                #     'Created glossary entry {} {}'.format(emp.Lemma, emp.Id_statico_entry)
                )

# You would then call this with:
# ./manage.py import_csv --csvfile "/home/<name>/webapps/<name2>/employees.csv"


#       python ./manage.py load_glossary csv_file "D:\Files Tommaso\Politecnico\Lavoro polimi\Algoritmi metaglossario Python\traformazioni di prova per il Metaglossario\dati_prova.csv"


++++++++


conda:

pip install django import-export

settings.py:

    INSTALLED_APPS = [
        'import_export',

admin.py:

from django.contrib import admin
from .models import glossary_entry 

from import_export import resources
from import_export.admin import ImportExportModelAdmin


class glossary_entry_resource(resources.ModelResource):
    class Meta:
        model=glossary_entry

class glossary_entry_Admin(ImportExportModelAdmin, admin.ModelAdmin):
    #resource_class = glossary_entry_resource
    pass


# Register your models here.
admin.site.register(glossary_entry, glossary_entry_Admin)

****

l'importazione da CSV è fallimentare, per importare dati usa i files xlsx

***

                        <p>
                        {% if entry.Url_definizione and entry.Url_definizione != "MISSING"  %}  
                            <a href="{{ entry.Url_definizione }}" Target= "_blank" class="btn btn-primary">Definizione</a> &nbsp                     
                        {% endif %}
                        </p>
                        
                        
                        <p>               
                        {% if entry.Url_documento_fonte and entry.Url_documento_fonte != "MISSING" %}  
                            <a href="{{ entry.Url_documento_fonte }}" Target= "_blank" class="btn btn-primary">Documento fonte</a> &nbsp                   
                        {% endif %}                                  
                        </p>

Ne faccio a meno perchè è problematico. meglio eliminare i missing prima di inserire i fogli. 
Il database di django è molto meglio per gestire i dati mancanti piuttosto che dargli un nome ap priori e fare mille speculazioni su cosa fare

oscurati per praticità i pulsanti url


l'errore a questa linea
 <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">

è colpa di un url tag chiuso male in seguito

href="{% url 'home' %}"
va a prendere l'url mappato e riferito al template home, appellativo di home.html

href={% static "css/searchbar_style.css" %}
va a prendere il file al percorso inicato, nella cartella static, 
appellativo che ho dato alla cartella static(il nome dato a stati è specificato in settings.py)

ho cambiato il form della terminologia in modo da nascondere la data

        <div class="form-group">
              <!-- <label for="glossary_entry_input_13">Data di inserimento della terminologia</label>
              <small id="inputHelp" class="form-text text-muted">Compilare solo se è nota la data di pubblicazione del documento fonte, altrimenti inserire la data di oggi.</small>-->
               <input name="Data_inserimento_entry" type="hidden" class="form-control" id="date_to_turn_into_toda">              
        </div>

ma rimane il javascript

<script type="text/javascript" src={% static "js/get_today_date.js" %}></script>
<script> get_today_date() </script> 

fare le ombre in css
  .form-group input:hover{
    
    /* border-color: red; */
    box-shadow: 0 0 10px #ced4da;
    

    
  }

  
  *******


  https://django.readthedocs.io/en/2.2.x/topics/http/file-uploads.html

  registrato il nuovo modello nell'admin

  MEDIA_ROOT e MEDIA_URL sono variabili i cui nomi non possono essere cambiati a piacimento e vanno utilizzati per indicare url e directory dei file salvati



  *****

  TemplateSyntaxError at /carica_glossario
Invalid block tag on line 89: 'static', expected 'endblock'. Did you forget to register or load this tag?

*******

vuol dire che stai mettendo javascipt o css prima del  tag {% load static %}

****

SE MODIFICO L'ID NEL TEMPLATE NON FUNZIONA,
SE MODIFICO L'ID NELLA FUNZIONE FUNZIONA, PERCHè?

l'ho corretto cambiando tutto:
file js, funzione e id nell'input del template

            <div class="form-group">
                <!-- <label for="glossary_entry_input_13">Data di inserimento della terminologia</label>
                <small id="inputHelp" class="form-text text-muted">Compilare solo se è nota la data di pubblicazione del documento fonte, altrimenti inserire la data di oggi.</small>-->
                 <input name="Data_inserimento_glossary" type="hidden" class="form-control" id="mettici_data_di_oggi">              
            </div>


<!-- Javascript -->
<script type="text/javascript" src={% static "js/data_oggi.js" %}> </script> 
<script> attualizza_data_di_ID("mettici_data_di_oggi") </script> 

<!-- static/js/data_oggi.js -->
function attualizza_data_di_ID(id_data) {
    var now = new Date();
    var day = ("0" + now.getDate()).slice(-2);
    var month = ("0" + (now.getMonth() + 1)).slice(-2);
    var today = now.getFullYear()+"-"+(month)+"-"+(day);
    document.getElementById(id_data).value = today;
    }


    ****

    home e aggiungi terminologia hanno lo stesso layout
    glossario e aggiungi glossario hanno lo stesso

    caricament glossario risolto: c era un mismatch tra nome file salvato temlate e nome form+modello

    template:

        <form method="POST" action="" enctype="multipart/form-data" >
        {% csrf_token %}

        <div class="file-upload-wrapper" id="input-file-now">

            <small id="inputHelp" class="form-text text-muted">Seleziona il template compilato con la terminologia da caricare. <br>Non sono accettati i file maggiori di 5M.</small>                  
            <input type="file"  name="Glossary_file" id="input-file-now" data-max-file-size="5M" class="file-upload">
            
            <br><br> 

            <!-- entry della data è nascosto -->
            <!-- in futuro posso rendere da forms.py il fatto che html non devono essere presi certi campi, quindi al posto di nasconderli tolgo proprio l'input. però devo far sì che nel modello si generino da soli se non specificati dall'utente -->
            <div class="form-group">
                <!-- <label for="glossary_entry_input_13">Data di inserimento della terminologia</label>
                <small id="inputHelp" class="form-text text-muted">Compilare solo se è nota la data di pubblicazione del documento fonte, altrimenti inserire la data di oggi.</small>-->
                 <input name="Data_inserimento_glossary" type="hidden" class="form-control" id="mettici_data_di_oggi">              
            </div>
            <!-- la data funziona - ho controllato -->
  
            <div class="container">
                <button type="submit" class="btn btn-primary">Carica glossario</button>
            </div>
        </div>

    </form>

forms.py:

    class glossary_file_form(forms.ModelForm):

    class Meta:
        model = glossary_file
        fields = ["Glossary_file", "Data_inserimento_glossary"]

models.py:

class glossary_file(models.Model):

    Glossary_file = models.FileField(upload_to='uploaded_glossaries/', blank=False, null=False)

    Data_inserimento_glossary = models.DateField(blank=False, null=False, default=timezone.now().date() )
    # Data_inserimento_entry = models.DateField(blank=False, null=False, default=timezone.now().date)


    class Meta:
        ordering = ['Data_inserimento_glossary', 'Glossary_file']
        # il meno davanti all'attributo vuol dire che ordina al contrario
        # '-Admin_approval_switch', 
        # faccio comparire per primi gli hide-> nuovi inseriti
        # in realtà per come ho definito hide e show, se metto senza il meno davanti, mi mostra per prima hide (h viene prima di s)

    def clean(self):
        if not (self.Glossary_file or self.Data_inserimento_glossary):
            raise ValidationError("Non è stato selezionato alcun glossario per il caricamento.")
        # non mi restituisce questa scritta ma quella messa di default nelle views

    def __str__(self):    
        # print("%s is %d years old." % (name, age))    
        return  "%s ----- [%s]"  %  (self.Glossary_file, self.Data_inserimento_glossary)  
        #quello che fa apparire nella sezione admin, attributo che riassume tutti gli altri, quindi una primary key presumibilmente, pouò anche esesere la combinazione degli altri

views.py:

def aggiungi_glossario(request):

    #se si esegue il POST (click del pulsante submit)
    if request.method=='POST': 

        form = glossary_file_form(request.POST or None, request.FILES or None)
        # form = glossary_file_form(request.POST, request.FILES)

        if form.is_valid():
            form.save()
            insert_attempt_output="corretto"
            # insert_attempt_output formatta il colore del messaggio, vedi in base.html
            messages.success(request, ("Glossario inserito con successo!\nAttendere la convalida da parte dell\'amministratore.\n Per favore non inserire di nuovo la stessa terminologia"))
            return redirect('aggiungi_glossario')

        else:
            insert_attempt_output="errato"
            messages.error(request, ('ERRORE: Non è stato caricato alcun glossario.'))
            return render(request, 'aggiungi_glossario.html', {'insert_attempt_output':insert_attempt_output})
    
    # se si va sulla pagina e basta
    else:   
        return render(request, 'aggiungi_glossario.html', {}) 

cambiato percosto internet di aggiungi glossario in aggiungi terminologia massa

prima della modificato
def glossario(request):

    query = request.GET.get('q') #q è variabile risultante dalla query del database
    template = "glossario.html" #il template è sempre lo stesso

    # se la query è stata fatta
    if query:
        
        query = request.GET.get('q') #q è variabile risultante dalla query del database
        selected_entries = glossary_entry.objects.filter(Q(Acronimo__icontains=query)|Q(Ambito_riferimento__icontains=query)|Q(Autore_definizione__icontains=query)|Q(Autore_documento_fonte__icontains=query)|Q(Data_inserimento_entry__icontains=query)|Q(Definizione__icontains=query)|Q(Host_documento_fonte__icontains=query)|Q(Id_statico_entry__icontains=query)|Q(Lemma__icontains=query)|Q(Posizione_definizione__icontains=query)|Q(Titolo_documento_fonte__icontains=query)|Q(Url_definizione__icontains=query)|Q(Url_documento_fonte__icontains=query))
        
        
        # context = {'all_entries':selected_entries}
        #return render(request, template, context)
        return render(request, template, {'all_entries':selected_entries})

    # se non è stata fatta nessuna query
    else:

        all_entries = glossary_entry.objects.all #funziona lo stesso anche se dice Class 'glossary_entry' has no 'objects' memberpylint(no-member)
        return render(request, template, {'all_entries':all_entries})

****

TypeError at /glossario
object of type 'method' has no len() 

probabile errore nel template

riolto mettendo aggiungendo () in views alla linea

all_entries = glossary_entry.objects.all()

per qualche motivo mi dava errore qui 

all_entries = paginator.get_page(page) 

*****

se al paginator ne aggiungo altri in costruzione mi da errore empty page perchè ho il template che contiene i djajngo tags e lo manda in palla


****

il mio paginatore:

<nav aria-label="...">
            <ul class="pagination">

                {% if all_entries.has_previous %}

                <li class="page-item">
                    <a class="page-link" href="?page=1">&laquo; first</a> 
                </li>
                    
                <li class="page-item">
                    <a class="page-link" href="?page={{ all_entries.previous_page_number }}">{{ all_entries.previous_page_number }}</a>
                </li>

                {% else %}

                <li class="page-item disabled">
                    <a class="page-link" href="#" class="page-item disabled">&laquo; first</a>  
                </li> 
                
                <!-- <li class="page-item disabled"></li>
                    <a class="page-link" href="#" class="page-item disabled">previous</a>
                </li> -->

                {% endif %}



                <li class="page-item active">
                <a class="page-link" href="#">{{ all_entries.number }}<span class="sr-only">(current)</span></a>
                </li>



                {% if all_entries.has_next %}
                    
                <li class="page-item">
                    <a class="page-link" href="?page={{ all_entries.next_page_number }}">{{ all_entries.next_page_number }}</a>
                </li>

                <li class="page-item">
                    <a class="page-link" href="?page={{ all_entries.paginator.num_pages }}">Last &raquo;</a> 
                </li>

                {% else %}
                               
                <!-- <li class="page-item disabled"></li>
                    <a class="page-link" href="#" class="page-item disabled">next</a>
                </li> -->

                <li class="page-item disabled">
                   <a class="page-link" href="#" class="page-item disabled">Last &raquo;</a>  
                </li> 
                
                {% endif %}

            </ul>
        </nav>

questo l'avevo implementato ma non funziona:

# per ora non funziona

# myapp/management/commands/load_glossary.py
from django.core.management.base import BaseCommand, CommandError
import csv

class Command(BaseCommand):

    def add_arguments(self, parser):
        parser.add_argument('csv_file', nargs='+', type=str)

    def handle(self, *args, **options):
        for csv_file in options['csv_file']:
            dataReader = csv.reader(open(csv_file), delimiter=',', quotechar='"')
            for row in dataReader:
                
                Lemma=row[0],
                Acronimo=row[1],
                Definizione=row[2],
                Ambito_riferimento=row[3],
                Autore_definizione=row[4],
                Posizione_definizione=row[5],
                Url_definizione=row[6],
                Titolo_documento_fonte=row[7],
                Autore_documento_fonte=row[8],
                Host_documento_fonte=row[9],
                Url_documento_fonte=row[10],
                Commento_entry=row[11],
                Data_inserimento_entry=row[12],
                Id_statico_entry=row[13],
                
                # etc...
                self.stdout.write(
                    'Created glossary entry'
                #     'Created glossary entry {} {}'.format(emp.Lemma, emp.Id_statico_entry)
                )

# You would then call this with:
# ./manage.py import_csv --csvfile "/home/<name>/webapps/<name2>/employees.csv"


#       python ./manage.py load_glossary csv_file "D:\Files Tommaso\Politecnico\Lavoro polimi\Algoritmi metaglossario Python\traformazioni di prova per il Metaglossario\dati_prova.csv"

************************************

django admin import export,
problemi di importazione potrebbero essere legati alla lunghezza massima dei campi nel modello
servono circa 25 secondi per importare 70 record. con import export da admin

