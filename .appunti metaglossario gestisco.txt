
<!-- """ sintassi:  <a href="{% url 'nome_dell'url messo in urls.py %}">Pagina iniziale</a> """ -->

django è in grado di parsare il testo attraverso i commenti per trovare i tag di tipo {%  %}

<li class="nav-item"> scritta normale
<li class="nav-item active"> scritta evidenziata

home originariamente è class="navbar-brand"

heroku git:remote -a Glossario_Gestisco


# print("%s is %d years old." % (name, age))    
return  "%s / %s - %s"  %  (self.Lemma_it, self.Lemma_ch, self.Id_statico_entry)  #quello che fa apparire nella sezione admin, attributo che riassume tutti gli altri, quindi una primary key presumibilmente, pouò anche esesere la combinazione degli altri

In case you want to sort the set with respect to two attributes, this is the command:

    class Meta:
        ordering = ['last_name', 'first_name']

git push heroku master vuol dire: spingi il codice sul ramo master (main) di heroku


    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <link rel="icon" href="www.metaglossario.polimi.it/img/favicon/gestisco_logo_round_favicon2.png">
    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">



        <div class="glossary-form"></div>

            <div class="form-group" style="display:inline-block; width:48%;">
              <label for="glossary_entry_input_1">Lemma IT</label>
              <input type="text" class="form-control" id="glossary_entry_input_1" placeholder="">              
            </div>

            <div class="form-group" style="display:inline-block; width:48%; float: right;">
                    <label for="glossary_entry_input_2">Lemma CH</label>
                    <input type="text" class="form-control" id="glossary_entry_input_2" placeholder="">              
            </div>

    a capo e non a capo è "toggle words wrap"

    <input name="Id_statico_entry" value="ciaone" type="text" class="form-control" id="glossary_entry_input_22" placeholder="">              
         
<!-- django vuole lo spazio tra gli operatori di uguaglianza o disuguaglianza -->


A POST bundles up form data, encodes it for transmission, sends it to the server, and then receives a response. Any request that changes the state of the database–creates, edits, or deletes data–should use a POST.

A GET bundles form data into a string that is added to the destination URL. GET should only be used for requests that do not affect the state of the application, such as a search where nothing within the database is changing, we’re just doing a filtered list view basically.


***

modificare l'apparenza di glossario.html in moodo che :

se esiste almeno un campo svizzero
e contemporaneamente
esiste almeno un campo italiano

mostra la view di quel singolo elemento appaiata

altrimenti

mostra la view di quel singolo elemento su una sla linea


far funzionare le funzioni javascript in un file esterno:

HTML, prima del body closing tag:

    <script type="text/javascript" src={% static "js/prova.js" %}></script>

    <script>
    funprova();
    </script> 

Nel file javascript chiamato prova.js , situato nella directory static/js/prova.js:

    function funprova() {
        alert("Hello! I am an alert box from remote js file!!");
        }

vedi https://stackoverflow.com/questions/57953127/how-to-have-javascript-presets-todays-date-in-html-form/57989051#57989051



clonare progetti da github verso il locale

https://help.github.com/en/articles/cloning-a-repository


funzionamento del block content, per aggiungere a tutte le pagine la stessa cosa


    <div class="container">

      <!-- INSERISCI QUI L'INIZIO PAGINA -->

        {% block content %}

        <!-- INCOLLARE COSE QUI IN MEZZO NON SERVE PERCHè NON LE RAPPRESENTA -->

        {% endblock %}

        
        <!-- INSERISCI QUI IL PIè DI PAGINA -->

      </div>

nelle pagine dove copiare le cose inserisco

{% extends 'base.html'%} <!-- vuol dire inserisci contenuti da base.html -->

{% block content %} (dove voglio che inizi)

{% endblock %} (dove voglio che finisca)

***

quando chiamo la shell di python da anaconda finisco nella stessa directory in cui sono con anaconda.

Implementare un form che prende in ingresso files excel caricati dagli utenti

https://docs.djangoproject.com/en/2.2/topics/http/file-uploads/

*****

per maneggiare il file importato uso una api di Django, la class FileSystemStorage, da usare in views.py

scrittura solo temporanea

----------

def carica_glossario(request):

    #se si esegue il POST (click del pulsante submit)
    if request.method=='POST': 
        uploaded_file=request.FILES['uploaded_glossary']
        print(uploaded_file.name)
        print(uploaded_file.size)
        fs=FileSystemStorage()
        fs.save(uploaded_file.name, uploaded_file)
        
        # request.POST è il contenuto inserito dagli utenti perchè request è il paramentro in ingresso della funzione

        if form.is_valid(): # funzione che controlla la coerenza dei campi (mail, url, numerico, testo, ecc.)
            form.save()
            insert_attempt_output="corretto"
            messages.success(request, ("Glossario caricato con successo!\nAttendere la convalida da parte dell\'amministratore.\n Per favore non caricare di nuovo lo stesso glossario"))
            return redirect('carica_glossario')
            # con redirect non posso usare .html, ma per forza names

        else:
            insert_attempt_output="errato"
            messages.error(request, ('ERRORE: Il glossario non è stato caricato.\nVerificare che nel glossario non siano stati inseriti caratteri speciali'))
            return render(request, 'carica_glossario.html', {'insert_attempt_output':insert_attempt_output})
    
    # se si va sulla pagina e basta
    else:   
        return render(request, 'carica_glossario.html', {}) 

    -----------

    nei form html, in input, il class determina i widget che vengono fuori

    https://www.youtube.com/watch?v=Rr1-UTFCuH4


    
    
    
    ****

    glossario prima di modifiche

    def glossario(request):

    query = request.GET.get('q') #q è variabile risultante dalla query del database
    # non sostuituirla col valore vuoto

    template = "glossario.html" #il template è sempre lo stesso

    all_entries = glossary_entry.objects.all() #funziona lo stesso anche se dice Class 'glossary_entry' has no 'objects' memberpylint(no-member)
    
    # se la query è stata fatta
    if query:
        
        query = request.GET.get('q') #q è variabile risultante dalla query del database
        selected_entries = glossary_entry.objects.filter(Q(Acronimo__icontains=query)|Q(Ambito_riferimento__icontains=query)|Q(Autore_definizione__icontains=query)|Q(Autore_documento_fonte__icontains=query)|Q(Data_inserimento_entry__icontains=query)|Q(Definizione__icontains=query)|Q(Host_documento_fonte__icontains=query)|Q(Id_statico_entry__icontains=query)|Q(Lemma__icontains=query)|Q(Posizione_definizione__icontains=query)|Q(Titolo_documento_fonte__icontains=query)|Q(Url_definizione__icontains=query)|Q(Url_documento_fonte__icontains=query))
        # Q(Acronimo__icontains=query dice quali sono i campi in cui cercare l'input specificato dall'utente
        
        # Pagination        
        paginator = Paginator(selected_entries, 10) # Show 25 contacts per page
        page = request.GET.get('page')
        selected_entries = paginator.get_page(page)
        
        # context = {'all_entries':selected_entries}
        #return render(request, template, context)
        # {'nome della variabile con cui sarà richiamato nel template':contenuto}
        return render(request, template, {'all_entries':selected_entries})

    # se non è stata fatta nessuna query
    else:

        # Pagination
        paginator = Paginator(all_entries, 10) # Show 25 contacts per page
        page = request.GET.get('page')
        all_entries = paginator.get_page(page)

        return render(request, template, {'all_entries':all_entries})

    

    {{ query_initial_url }}


    ********

      for element in all_entries[:10]:
        print(element.Lemma)


print(len(col_lemma))

        # print(col_lemma[23]) 
        # break


    # iterating over rows using iterrows() function  
for i, j in df.iterrows(): 
    print(i, j) 
    print() 


    df.sort_values(['Total Due']) returns a sorted DF, but it doesn't update DF in place.

So do it explicitly:

df = df.sort_values(['Total Due'])
or

df.sort_values(['Total Due'], inplace=True)


 is_Acronimo_of = pd.concat([ Elab1["ID_db_Acronimo"], Elab1["ID_db_Lemma"], Elab1["Acronimo"], Elab1["Lemma"] ], axis=1)


    # concatena in colonna gli id di tutti gli oggetti
    # incolla uno sotto l'altra le colonne degli id
        

    Things_ID = pd.concat([Elab1[j] for j in nomi_campi_prepared_terminology], axis=0) 


ricordati di fare x = pd.DataFrame(x)
altrimenti non funzioneranno le etichette label quando richiamato l'oggetto

    **********
    nei cicli non usare l'uguale ma usa invece append


    dare il plurale all'admin section modelli

    class Meta:
        verbose_name_plural = "Categories"


        fai modello come elab 1

        poi pubblica normalemente ma mettendo come url di ogni oggetto la query del proprio id db

        segui l'algoritmo WD


class Things(models.Model):
    ID_Thing = models.CharField(max_length=50)
    Thing = models.TextField()

class Relations(models.Model):
    Lemma_s = models.ManyToManyField(Things)
    Acronimo_s = models.ManyToManyField(Things)


potrei incentrarlo sulla definizione... ma poi altre cose non toccano la definizione

+++++++

class Person(models.Model):
    name = models.CharField(max_length=50)
    description = models.TextField()

class Club(models.Model):
    name = models.CharField(max_length=50)
    members = models.ManyToManyField(Person)
Here we define a relationship where a club has many Persons and members and a Person can be a member of several different Clubs.


Though we define only two models, django actually creates three tables in the database for us. 
These are myapp_person, myapp_club and myapp_club_members. 
Django automatically creates a unique index on myapp_club_members(club_id,person_id) columns

class Thing(models.Model):
    Thing = models.CharField(max_length=50)

class Lemma(models.Model):
    acronym = models.ManyToManyField(Thing)

una thing diventa acronym o quello che c e nel nome della variavile cos' come
la persona diventava un embro blu, rosso eo viola del club

ora di nuovo es1





tom = Person.objects.create(name="Tom", description="A nice guy")
bill = Person.objects.create(name="Bill", description="Good dancer")

nightclub = Club.objects.create(name="The Saturday Night Club")
nightclub.members.add(tom, bill)


acronimo_curr = Thing.objects.create(name="IPCC")

lemma_curr = Lemma.objects.create(name="intergovernamental panel on cc")
lemma_curr.acronym.add(acronimo_curr)


acronimo_curr = Thing.objects.create(name="IPCC")

lemma_curr = Lemma.objects.create(name="intergovernamental panel on cc")
lemma_curr.acronym.add(acronimo_curr)

thing_curr = cosa selezionata dalla tabella, es. acronimo

lemma_curr = Lemma.objects.create(name=lemma corrispondente alla cosa selezionata sulla tabella)
lemma_curr.acronym.add(acronimo_curr)


thing_curr = cosa selezionata dalla tabella, es. acronimo --> Thing.objects. ??? seleziona

lemma_curr.acronym.add(acronimo_curr)

for thing_curr in lemma_curr.acronym.all():
    print(thing_curr.thing)  


    *************


metti la struttura delle tabelle col related names come avevo fatto nella domanda di stack overflow

poi scorri la tabella Things

nel template prendo thing come principale, mi salvo l id


se nella tabella relaz [j] ]c'è quel id come soggetto, stampa label[j] e oggetto corrisp (viene tradotto automaticamente col suo nome)


things entries = things objec all

for i in things

print <h1> things.thing </h1>

for j in tabelle relazionali

if things.id == tabella relaz.id soggetto [j]

print label[j] -> tabella relaz.id oggetto [j]


***********7


    import os    
    from django.contrib.staticfiles import finders

    saving_folder_name = 'saved_dataframes'

    saving_file_name = 'output_table.xlsx'

    result = finders.find(saving_folder_name)
    searched_locations = finders.searched_locations

    # print(searched_locations[0])
    # print(os.path.join(searched_locations[0]+r'\sounds\1607.mp3'))

    df_dir = os.path.join(searched_locations[0]+r'\\'+saving_folder_name+r'\\'+saving_file_name)

    df1 = pd.DataFrame([['a', 'b'], ['c', 'd']])
    df1.to_excel(df_dir)

**************

https://www.youtube.com/watch?v=D2lwk1Ukgz0&list=PL-osiE80TeTtoQCKZ03TU5fNfx2UY6U4p&index=14

*********

{% extends 'base.html'%} <!-- vuol dire inserisci qui la navigation toolbar contenuta in base -->

{% block content %}

    <h1>Glossario</h1>
    
    <br>

    <!-- Barra di navigazione  -->

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> <!-- questo fa apparire il pulsantino di ricerca -->
    <!-- questo fa apparire il pulsantino di ricerca -->

    <div class="topnav">
        
        <a id="pulsante_ricerca_avanzata" href="#Ricerca_avanzata" onclick="alert('Funzione non ancora disponibile.')">Ricerca avanzata</a>
        
        <div id="blocco_ricerca_semplice" class="search-container">

          <form method="GET" action="{% url 'glossario' %}">
            
            <input id="testo_slot_ricerca_semplice"  type="text" placeholder="Ricerca terminologia..." name="q" value="{{request.GET.q}}">  <!-- è il nome che ho dato anche nella views.py -->
            <!-- name dentro input text vuol dire il sintagma che viene dato all'url di tutte le query, seguito da un = per indicarne il bersaglio'  -->
            
            

            <!-- #cerca -->
            <button id="search_button" type="submit"><i class="fa fa-search"></i></button>

            
            <!-- cancella query -->
            <button id="cancel_search_button" type="submit" onclick="Delete_simple_search()"><i class="fa fa-trash"></i></button>
            
            <!-- vai all'indice -->
            <button id="goto_index_button" action="{% url 'indice_glossario' %}"><i class="fa fa-trash"></i></button>
            

          </form>

          
        </div>

    </div>


    <br>

<!-- visualizzazione glossario intero o risultati ricerca -->

    {% if all_entries %}

        {% for entry in all_entries %}

            {% if entry.Admin_approval_switch == "show" %} 
            <!-- django vuole lo spazio tra gli operatori di uguaglianza o disuguaglianza -->

                    <div class="card">
                        <div class="card-body"> 
                            

                        {% if entry.Lemma %}  
                            <p class="card-text"><h4 class="card-title">{{ entry.Lemma }}</h4></p>                           
                        {% endif %}


                        {% if entry.Acronimo %}                
                            <p class="card-text"><b>Acronimo:</b> {{ entry.Acronimo }}</p>                             
                        {% endif %}

            
                        {% if entry.Definizione %}                
                            <p class="card-text"><b>Definizione:</b> {{ entry.Definizione }}</p>                             
                        {% endif %}            

            
                        {% if entry.Ambito_riferimento %}                
                            <p class="card-text"><b>Ambito di riferimento del concetto:</b> {{ entry.Ambito_riferimento }}</p>                             
                        {% endif %}            

            
                        {% if entry.Autore_definizione %}                
                            <p class="card-text"><b>Autore della definizione:</b> {{ entry.Autore_definizione }}</p>                             
                        {% endif %}            

            
                        {% if entry.Posizione_definizione %}                
                            <p class="card-text"><b>Posizione della definizione nel documento fonte:</b> {{ entry.Posizione_definizione }}</p>                             
                        {% endif %}            

                        
                        {% if entry.Url_definizione %}                
                            <p class="card-text"><b>URL della definizione:</b> <a href="{{ entry.Url_definizione }}" target="_blank">{{ entry.Url_definizione }}</a></p>                          
                        {% endif %}            

            
                        {% if entry.Titolo_documento_fonte %}                
                            <p class="card-text"><b>Titolo del documento fonte:</b> {{ entry.Titolo_documento_fonte }}</p>                             
                        {% endif %}            

            
                        {% if entry.Autore_documento_fonte %}                
                            <p class="card-text"><b>Autore del documento fonte:</b> {{ entry.Autore_documento_fonte }}</p>                             
                        {% endif %}            

            
                        {% if entry.Host_documento_fonte %}                
                            <p class="card-text"><b>Host del documento fonte:</b> {{ entry.Host_documento_fonte }}</p>                             
                        {% endif %}            

            
                        {% if entry.Url_documento_fonte %}                
                            <p class="card-text"><b>URL del documento fonte:</b> <a href="{{ entry.Url_documento_fonte }}" target="_blank">{{ entry.Url_documento_fonte }}</a></p>                           
                        {% endif %}           
                        

                        {% if entry.Data_inserimento_entry %}                
                            <p class="card-text"><b>Data di inserimento delle informazioni:</b> {{ entry.Data_inserimento_entry }}</p>                             
                        {% endif %}
            
                        
                        <!-- Il commento lo rendo visibile solo all'admin -->
                        <!-- {% if entry.Commento_entry %}                
                            <p class="card-text"><b>Commento/Altro:</b> {{ entry.Commento_entry }}</p>                             
                        {% endif %} -->

            
                        {% if entry.Id_statico_entry %}                
                            <p class="card-text"><b>ID delle informazioni:</b> {{ entry.Id_statico_entry }}</p>                             
                        {% endif %}
                        
                        
                        <!-- PULSANTI URL -->
                        <!-- per ora preferisco oscurarli -->

                        <!-- <p>
                        {% if entry.Url_definizione %}  
                            <a href="{{ entry.Url_definizione }}" Target= "_blank" class="btn btn-primary">Definizione</a> &nbsp                     
                        {% endif %}
                        </p>
                        
                        
                        <p>               
                        {% if entry.Url_documento_fonte %}  
                            <a href="{{ entry.Url_documento_fonte }}" Target= "_blank" class="btn btn-primary">Documento fonte</a> &nbsp                   
                        {% endif %}                                  
                        </p> -->

                     
                    
                    </div>        
                </div> 
                
                <br> <!-- spazio tra le card -->

            {% endif %} <!--questo if è per pubblicare il contenuto solo se lo switch della review è passata-->
        
        {% endfor %}

    {% endif %}


    <br><br> <!-- spazio dopo i risultati impaginati -->       

    <div class="navigation" id="navigation_box">
    <!-- navigation è una classe inventata -->

        <nav aria-label="...">
            <ul class="pagination">
                
            <!-- Se la q ha ricevuto un input = la search bar ha inserito input -->    
            {% if query %}
                                
                {% if all_entries.has_previous %}
                
                    <li class="page-item">
                        <a class="page-link" href="?q={{ query }}&page=1">&laquo; Prima pagina</a> 
                    </li>
                        
                    <li class="page-item">
                        <a class="page-link" href="?q={{ query }}&page={{ all_entries.previous_page_number }}">{{ all_entries.previous_page_number }}</a>
                    </li>

                {% else %}

                    <li class="page-item disabled" >
                        <a  class="page-link" href="#" id="tasto_navigazione_pagina_disabilitato" class="page-item disabled">&laquo; Prima pagina</a>  
                    </li>

                {% endif %}


                <li class="page-item active">
                <a class="page-link" id="active_page_sign" href="#">{{ all_entries.number }}<span class="sr-only">(current)</span></a>
                </li>


                {% if all_entries.has_next %}
                    
                    <li class="page-item">
                        <a class="page-link" href="?q={{ query }}&page={{ all_entries.next_page_number }}">{{ all_entries.next_page_number }}</a>
                    </li>

                    <li class="page-item">
                        <a class="page-link" href="?q={{ query }}&page={{ all_entries.paginator.num_pages }}">Ultima pagina [ {{ all_entries.paginator.num_pages }} ] &raquo;</a> 
                    </li>

                {% else %}

                    <li class="page-item disabled" >
                    <a class="page-link" href="#" id="tasto_navigazione_pagina_disabilitato" class="page-item disabled">Ultima pagina [ {{ all_entries.paginator.num_pages }} ] &raquo;</a>  
                    </li> 
                
                {% endif %}

        <!-- Se la q è vuota = la search bar non ha inserito input -->
        {% else %}

        
            {% if all_entries.has_previous %}
                        
                <li class="page-item">
                    <a class="page-link" href="?page=1">&laquo; Prima pagina</a> 
                </li>
                    
                <li class="page-item">
                    <a class="page-link" href="?page={{ all_entries.previous_page_number }}">{{ all_entries.previous_page_number }}</a>
                </li>

            {% else %}

                <li class="page-item disabled"  >
                    <a class="page-link" href="#" id="tasto_navigazione_pagina_disabilitato" class="page-item disabled">&laquo; Prima pagina</a>  
                </li> 

            {% endif %}


            <li class="page-item active">
            <a class="page-link" id="active_page_sign" href="#">{{ all_entries.number }}<span class="sr-only">(current)</span></a>
            </li>


            {% if all_entries.has_next %}
                
                <li class="page-item">
                    <a class="page-link" href="?page={{ all_entries.next_page_number }}">{{ all_entries.next_page_number }}</a>
                </li>

                <li class="page-item">
                    <a class="page-link" href="?page={{ all_entries.paginator.num_pages }}">Ultima pagina [ {{ all_entries.paginator.num_pages }} ] &raquo;</a> 
                </li>

            {% else %} 

                <li class="page-item disabled"  >
                <a class="page-link" href="#" id="tasto_navigazione_pagina_disabilitato" class="page-item disabled">Ultima pagina [ {{ all_entries.paginator.num_pages }} ] &raquo;</a>  
                </li> 
            
            {% endif %}


        {% endif %}

            </ul>
        </nav>



        <!-- navigatore di paginazione manuale -->
        
        {% if query %}

            <form method="GET" >
                    <nav aria-label="...">
                        <ul class="pagination">
                        
                        <li class="page-item disabled" ><a id="vai_alla_pagina_disabilitato" class="page-link" >Vai alla pagina: </a></li>
                        <li class="hidden"><input type="hidden" name="q" value="{{request.GET.q}}"></li>
                        <li class="page-item"><input id="page_slot" style="width: 60px" class="page-link" name="page"></li>                    
                        <li class="page-item">&nbsp&nbsp&nbsp<button type="submit" class="btn btn-primary" href="?q={{query}}&page={{page}}">Vai</button></li>
                        </ul>
                        
                    </nav>
                </form>

        {% else %}

        <!-- se la query è vuota questo funziona -->

            <form method="GET" action="{% url 'glossario' %}">
                    <nav aria-label="...">
                        <ul class="pagination">
                        
                        <li class="page-item disabled" ><a id="vai_alla_pagina_disabilitato" class="page-link" >Vai alla pagina: </a></li>
                        <li class="page-item" ><input style="width: 60px; color:grey" class="page-link" name="page" value=""></li>
                        <li class="page-item">&nbsp&nbsp&nbsp<button type="submit" class="btn btn-primary">Vai</button></li>
                        </ul>
                        
                    </nav>
                </form>

            
        {% endif %}

    </div>            
    

    <br><br>


{% load static %}   <!-- Qui il tag è obbligatorio nonostante sia stato inserito dentro base.html -->


<!-- CSS -->
<link rel="stylesheet" type="text/css" href={% static "css/searchbar_style.css" %}>
<link rel="stylesheet" type="text/css" href={% static "css/navigation_box_style.css" %}>

<!-- Javascript -->
<script type="text/javascript" src={% static "js/delete_simple_search.js" %}></script>
<!-- script caricato ma non runnato -->

{% endblock %}


************



https://www.digitalocean.com/community/tutorials/how-to-serve-django-applications-with-uwsgi-and-nginx-on-ubuntu-14-04

dentro git bash

cd C:

cd Users

cd Tommaso


oppure
cd Users/Tommaso


SELECT things_2.thing AS Acronimo, things_3.thing AS Definizione, things.thing AS Ambito, things_4.thing AS autore_def, things_6.thing AS url_def, things_7.thing AS titolo_doc, things_8.thing AS autore_doc, things_9.thing AS URL_doc, things_10.thing AS Host_doc, things_1.thing AS Lemma FROM (things AS things_1 INNER JOIN ((things AS things_9 INNER JOIN is_Url_documento_fonte_of ON things_9.[ID_Thing] = is_Url_documento_fonte_of.[ID_soggetto]) INNER JOIN ((things AS things_10 INNER JOIN is_Host_documento_fonte_of ON things_10.[ID_Thing] = is_Host_documento_fonte_of.[ID_soggetto]) INNER JOIN ((things AS things_8 INNER JOIN is_autore_documento_of ON things_8.[ID_Thing] = is_autore_documento_of.[ID_soggetto]) INNER JOIN ((things INNER JOIN is_Ambito_riferimento_of ON things.[ID_Thing] = is_Ambito_riferimento_of.[ID_soggetto]) INNER JOIN ((((things AS things_4 INNER JOIN ((is_lemma_of INNER JOIN things AS things_3 ON is_lemma_of.[ID_oggetto] = things_3.[ID_Thing]) INNER JOIN is_autore_definizione_of ON things_3.[ID_Thing] = is_autore_definizione_of.[ID_oggetto]) ON things_4.[ID_Thing] = is_autore_definizione_of.[ID_soggetto]) INNER JOIN (things AS things_6 INNER JOIN is_url_definizione_of ON things_6.[ID_Thing] = is_url_definizione_of.[ID_soggetto]) ON things_3.[ID_Thing] = is_url_definizione_of.[ID_oggetto]) INNER JOIN (things AS things_5 INNER JOIN is_posizione_definizione_of ON things_5.[ID_Thing] = is_posizione_definizione_of.[ID_soggetto]) ON things_3.[ID_Thing] = is_posizione_definizione_of.[ID_oggetto]) INNER JOIN (is_Titolo_documento_fonte_of INNER JOIN things AS things_7 ON is_Titolo_documento_fonte_of.[ID_soggetto] = things_7.[ID_Thing]) ON things_3.[ID_Thing] = is_Titolo_documento_fonte_of.[ID_oggetto]) ON is_Ambito_riferimento_of.[ID_oggetto] = things_3.[ID_Thing]) ON is_autore_documento_of.[ID_oggetto] = things_7.[ID_Thing]) ON is_Host_documento_fonte_of.[ID_oggetto] = things_7.[ID_Thing]) ON is_Url_documento_fonte_of.[ID_oggetto] = things_7.[ID_Thing]) ON things_1.[ID_Thing] = is_lemma_of.[ID_soggetto]) INNER JOIN (things AS things_2 INNER JOIN is_Acronimo_of ON things_2.[ID_Thing] = is_Acronimo_of.[ID_soggetto]) ON things_1.[ID_Thing] = is_Acronimo_of.[ID_oggetto] ORDER BY things_1.thing;


https://www.digitalocean.com/community/tutorials/how-to-build-a-django-and-gunicorn-application-with-docker


******

backup del query wizard


{% extends 'base.html'%} <!-- vuol dire inserisci qui la navigation toolbar contenuta in base -->

{% block content %}

<h1>Query Wizard</h1>
<!-- (Al momento è un query box, devo trasformarlo in un wizard) -->
<p>Please type your SQL query in the box below:</p>


<div class="container">
  <form method="POST">
      {% csrf_token %}
      
      {{QWform.as_p}}
      <!-- Qui avevo scritto queryform e non funzionava, invece con QWform funziona -->

    <input type="submit" class="btn btn-primary" value="Run query">
  </form>

</div>

<br>
<!--  show tabella  -->

<h2>Query result:</h2>



{% if queryresult_key %}

<br>

    <table>

        <tr style="font-weight: bold; text-align: center;">
            <td class="class_Tabella_Head">Lemma</td>
            <td class="class_Tabella_Head">Acronimo</td>
            <td class="class_Tabella_Head">Definizione</td>



        </tr>

    {% for row in queryresult_key %}
        <tr>
        {% for cell in row %}

            <td class="class_Tabella_Risultati">{{ cell }}</td>

        {% endfor %}
        </tr>
    {% endfor %}

    </table>



{% else %}


    {% if len_result_list_key == 0 %} <!-- se non c'è niente nella lista dei risultati -->

    <p class="class_expect_query">No match found</p>

    {% else %}

    <p class="class_expect_query">Waiting for you to run the query</p>

    {% endif %}




{% endif %}


<br><br><br>
    
{% load static %}
<!-- CSS -->
<link rel="stylesheet" href="{% static "css/qw_style.css" %}"/>
    

{% endblock %}



*************

backup view query wizard

query_wizard(request):
    
    # from app_metaglossario import forms
    # from forms import QueryFormName

    QWform = QueryFormName()


    if request.method == 'POST': #se qualcuno clicca su "submit", cioè esegue una post
        QWform = QueryFormName(request.POST)

        if QWform.is_valid(): #validation check
            
            print("Query SQL acquisita:"+ QWform.cleaned_data['SQL_query'])
            #esempio SELECT * FROM things2 WHERE ID_Things <1000021

            # agisci qui

            import psycopg2 as pg2

            # questo poi come lo nascondo?
            mydb = pg2.connect(user='zogpunyhfdizcj', password='e4e8bbb8ef02572179d0ccdc1a146d4f2eba03e587525349bb4436a80b87f4ec',
                                          host='ec2-46-51-190-87.eu-west-1.compute.amazonaws.com', database='dfibp7p1uu70v7')

            #'postgres://zogpunyhfdizcj:e4e8bbb8ef02572179d0ccdc1a146d4f2eba03e587525349bb4436a80b87f4ec@ec2-46-51-190-87.eu-west-1.compute.amazonaws.com:5432/dfibp7p1uu70v7')
            #postgres://user:password@host:porta/database_name

            # import mysql.connector

            # # connect to the database
            # mydb = mysql.connector.connect(user='root', password='metaglossariov2',
            #                               host='localhost', database='schema_meta_prova')


            

            my_cursor = mydb.cursor()
            my_cursor.execute(QWform.cleaned_data['SQL_query'])

            query_result_list = my_cursor.fetchall()

            len_result_list = len(query_result_list)
           
            #Parla alla console
            print("Query eseguita sul database con successo, risultati inviati al browser!")

            # print("************************************")
            # print("Risutati della query:")

            # so che mi ritorna una lista di tuple: allora mi preparo a stampare con un doppio ciclo for a mo' di matrice
            # for record in query_result_list:
            #     for entity in record:
            #         print(entity)
            #     print("---")

            print("************************************")

            #devo creare una matrice
            context_diz={'QWform':QWform, 'queryresult_key' :query_result_list, 'len_result_list_key':len_result_list}
            # non ho una views che ne crea il dizionario della chiave e della lista
            # faccio una vista che mi ritorna entrambe le cose con un dzionario a due elementi

    else:
        context_diz={'QWform':QWform}

    return render(request,'query_wizard.html',context_diz)


    §§§§§§§§§§§§§§§


    backup metaglossario html
    from django.shortcuts import render, redirect

from .models import glossary_entry
from .forms import glossary_entry_form

from .models import glossary_file
from .forms import glossary_file_form

from .models import acquired_terminology
from .models import prepared_terminology

# from .forms import glossary_sheet_form

# questo mi consente di lanciare i messaggi da una pagina all'altra
from django.contrib import messages

# per la ricerca
from django.db.models import Q

# per la paginazione
from django.core.paginator import Paginator
from django.core.paginator import EmptyPage, PageNotAnInteger

# per creare api e consentire di esportarle
from django.http import JsonResponse


# per i messaggi a capo
# from django.utils.safestring import mark_safe

# per caricare i files dagli utenti
from django.core.files.storage import FileSystemStorage

# per gli script di management dei files
from .algoritmi_processing.script_gestione import *

# per gli script di calcolo tempo degli algoritmi
from .algoritmi_processing.script_ausiliari import *

# per gli script di elaborazione della terminologia
from .algoritmi_processing.PGI import algoritmo_PGI
from .algoritmi_processing.SR import algoritmo_SR
from .algoritmi_processing.WD import algoritmo_WD


# per il query wizard
# from .forms import QueryFormName



def run_script(request):   

    start_time = printout()
    # erase_glossary_entry()
    # erase_acquired_terminology()
    # pour_entire_simple_model()
    # pour_entire_file_model()
    # pour_latest_file()
    
    # algoritmo_PGI()
    algoritmo_SR()
    # algoritmo_WD()

    # erase_database_tables()

    import time
    elapsed_time = round(time.time() - start_time)

    print("*** Script eseguito fino alla fine! ***")
    print("*** Tempo impiegato: %s s ***" % elapsed_time )

    finish_sound()

    return render(request, 'run_script.html', {})





# Create your views here.
def home(request):
    return render(request, 'home.html', {})


def glossario(request):   

    query = request.GET.get('q') #q è variabile risultante dalla query del database
    # non sostuituirla col valore vuoto

    template = "glossario.html" #il template è sempre lo stesso

    all_entries = prepared_terminology.objects.all() #funziona lo stesso anche se dice Class 'glossary_entry' has no 'objects' memberpylint(no-member)

    # se la query è stata fatta
    if query:

        query = request.GET.get('q') #q è variabile risultante dalla query del database

        selected_entries = prepared_terminology.objects.filter(Q(Acronimo__icontains=query)|Q(Ambito_riferimento__icontains=query)|Q(Autore_definizione__icontains=query)|Q(Autore_documento_fonte__icontains=query)|Q(Data_inserimento_entry__icontains=query)|Q(Definizione__icontains=query)|Q(Host_documento_fonte__icontains=query)|Q(Id_statico_entry__icontains=query)|Q(Lemma__icontains=query)|Q(Posizione_definizione__icontains=query)|Q(Titolo_documento_fonte__icontains=query)|Q(Url_definizione__icontains=query)|Q(Url_documento_fonte__icontains=query))
        # Q(Acronimo__icontains=query dice quali sono i campi in cui cercare l'input specificato dall'utente

        # Pagination
        paginator = Paginator(selected_entries, 10) # Show 25 contacts per page
        page = request.GET.get('page')
        selected_entries = paginator.get_page(page)

        # context = {'all_entries':selected_entries}
        #return render(request, template, context)
        # {'nome della variabile con cui sarà richiamato nel template':contenuto}
        return render(request, template, {'all_entries':selected_entries, 'query':query})

    # se non è stata fatta nessuna query
    else:

        # Pagination
        paginator = Paginator(all_entries, 10) # Show 25 contacts per page
        page = request.GET.get('page')
        all_entries = paginator.get_page(page)

        return render(request, template, {'all_entries':all_entries, 'query':query})


# QUESTA è LA SINGOLA ENTRY
def aggiungi_terminologia(request):

    #se si esegue il POST (click del pulsante submit)
    if request.method=='POST':
        form = glossary_entry_form(request.POST or None)

        # request.POST è il contenuto inserito dagli utenti perchè request è il paramentro in ingresso della funzione

        if form.is_valid(): # funzione che controlla la coerenza dei campi (mail, url, numerico, testo, ecc.)
            form.save()
            insert_attempt_output="corretto"
            # insert_attempt_output formatta il colore del messaggio, vedi in base.html
            messages.success(request, ("Terminologia inserita con successo!\nAttendere la convalida da parte dell\'amministratore.\n Per favore non inserire di nuovo la stessa terminologia"))
            
            # per ora non lo uso
            # pour_latest_entry()

            return redirect('aggiungi_terminologia')
            # con redirect non posso usare .html, ma per forza names

        else:
            insert_attempt_output="errato"
            messages.error(request, ('ERRORE: La terminologia non è stata inserita nel glossario.\nCompilare almeno un campo e la data di inserimento.'))
            return render(request, 'aggiungi_terminologia.html', {'insert_attempt_output':insert_attempt_output})

    # se si va sulla pagina e basta
    else:
        return render(request, 'aggiungi_terminologia.html', {})



# per aggiungere la terminologia in massa
def aggiungi_glossario(request):

    #se si esegue il POST (click del pulsante submit)
    if request.method=='POST':

        form = glossary_file_form(request.POST, request.FILES)
        # form = glossary_file_form(request.POST, request.FILES)
        # funziona anche con
        # form = glossary_file_form(request.POST or None, request.FILES or None)

        if form.is_valid():
            form.save()
            insert_attempt_output="corretto"
            # insert_attempt_output formatta il colore del messaggio, vedi in base.html
            messages.success(request, ("Glossario inserito con successo!\nAttendere la convalida da parte dell\'amministratore.\n Per favore non inserire di nuovo la stessa terminologia"))
            
            #  per ora non lo uso
            # pour_latest_file()

            return redirect('aggiungi_glossario')

        else:
            insert_attempt_output="errato"
            messages.error(request, ('ERRORE: Non è stato caricato alcun glossario.'))
            return render(request, 'aggiungi_glossario.html', {'insert_attempt_output':insert_attempt_output})

    # se si va sulla pagina e basta
    else:
        return render(request, 'aggiungi_glossario.html', {})


# per esportare il contenuto glossario tramite API
def api_glossario(request):

    all_entries = prepared_terminology.objects.all() #[:30] #tutti fino al 30simo

    data = {"entries":list(all_entries.values("Lemma", "Acronimo", "Definizione", "Ambito_riferimento", "Autore_definizione", "Posizione_definizione", "Url_definizione", "Titolo_documento_fonte", "Autore_documento_fonte", "Host_documento_fonte", "Url_documento_fonte", "Commento_entry", "Data_inserimento_entry", "Id_statico_entry"))}

    response= JsonResponse(data)
    return response
    # qui manca il passaggio del template, ma forseva bene così

def pagina_api(request):
    return render(request, 'api.html', {})


def indice_glossario(request):   

    template = "indice_glossario.html" #il template è sempre lo stesso
    all_entries = prepared_terminology.objects.all() #funziona lo stesso anche se dice Class 'glossary_entry' has no 'objects' memberpylint(no-member)

    return render(request, template, {'all_entries':all_entries})





def metaglossario(request):
    
    # salva in variabile python ciò che il template mi indica come like_term, finisce anche nell'url
    # qui è vuoto
    like_term_query = request.GET.get('like_term')

    # senza  il comando LIKE
    Query_initial_string = "SELECT Lemmi.Thing, Acronimi.Thing, Definizioni.Thing FROM (app_metaglossario_model_is_Lemma_of INNER JOIN ((app_metaglossario_model_Things AS Acronimi INNER JOIN app_metaglossario_model_is_Acronimo_of ON Acronimi.ID_Thing = app_metaglossario_model_is_Acronimo_of.ID_soggetto) INNER JOIN app_metaglossario_model_Things AS Lemmi ON app_metaglossario_model_is_Acronimo_of.ID_oggetto = Lemmi.ID_Thing) ON app_metaglossario_model_is_Lemma_of.ID_soggetto = Lemmi.ID_Thing) INNER JOIN app_metaglossario_model_Things AS Definizioni ON app_metaglossario_model_is_Lemma_of.ID_oggetto = Definizioni.ID_Thing ORDER BY Lemmi.Thing"
   # metto questa perchè è per dire che di default la stringa di query è quella senza like

    #da access a django sql puro

    #per evitare confilitti nel like cambia " con '"

    #cambia * con %

    # i nomi delle tabelle e delle relazioni protrebbero cambiare

    # ricerca in tutti i campi acq, metodo OR
    # Query_initial_string = "SELECT Lemmi.Thing, Acronimi.Thing, Definizioni.Thing FROM (app_metaglossario_model_is_Lemma_of INNER JOIN ((app_metaglossario_model_Things AS Acronimi INNER JOIN app_metaglossario_model_is_Acronimo_of ON Acronimi.ID_Thing = app_metaglossario_model_is_Acronimo_of.ID_soggetto) INNER JOIN app_metaglossario_model_Things AS Lemmi ON app_metaglossario_model_is_Acronimo_of.ID_oggetto = Lemmi.ID_Thing) ON app_metaglossario_model_is_Lemma_of.ID_soggetto = Lemmi.ID_Thing) INNER JOIN app_metaglossario_model_Things AS Definizioni ON app_metaglossario_model_is_Lemma_of.ID_oggetto = Definizioni.ID_Thing WHERE (((Lemmi.Thing) Like '%acq%') OR ((Acronimi.Thing) Like '%acq%') OR ((Definizioni.Thing) Like '%acq%')) ORDER BY Lemmi.Thing"

    # backup original string
    # Query_initial_string = "SELECT Lemmi.Thing, Acronimi.Thing, Definizioni.Thing FROM (app_metaglossario_model_is_Lemma_of INNER JOIN ((app_metaglossario_model_Things AS Acronimi INNER JOIN app_metaglossario_model_is_Acronimo_of ON Acronimi.ID_Thing = app_metaglossario_model_is_Acronimo_of.ID_soggetto) INNER JOIN app_metaglossario_model_Things AS Lemmi ON app_metaglossario_model_is_Acronimo_of.ID_oggetto = Lemmi.ID_Thing) ON app_metaglossario_model_is_Lemma_of.ID_soggetto = Lemmi.ID_Thing) INNER JOIN app_metaglossario_model_Things AS Definizioni ON app_metaglossario_model_is_Lemma_of.ID_oggetto = Definizioni.ID_Thing"

    
    template = "metaglossario.html" #il template è sempre lo stesso

    # no modello eprchè mi connetto diretto al db

    # se la query è stata fatta
    if like_term_query:

        like_term_query = request.GET.get('like_term')

        # al posto di selected_entries

        # con il comando like con aggiunta dell'utente - solo termine like
        # l'element like_term è incatenato tra le % per usare il like con sql diretto
        Query_string = "SELECT Lemmi.Thing, Acronimi.Thing, Definizioni.Thing FROM (app_metaglossario_model_is_Lemma_of INNER JOIN ((app_metaglossario_model_Things AS Acronimi INNER JOIN app_metaglossario_model_is_Acronimo_of ON Acronimi.ID_Thing = app_metaglossario_model_is_Acronimo_of.ID_soggetto) INNER JOIN app_metaglossario_model_Things AS Lemmi ON app_metaglossario_model_is_Acronimo_of.ID_oggetto = Lemmi.ID_Thing) ON app_metaglossario_model_is_Lemma_of.ID_soggetto = Lemmi.ID_Thing) INNER JOIN app_metaglossario_model_Things AS Definizioni ON app_metaglossario_model_is_Lemma_of.ID_oggetto = Definizioni.ID_Thing WHERE (((Lemmi.Thing) Like '%" + like_term_query + "%') OR ((Acronimi.Thing) Like '%" + like_term_query + "%') OR ((Definizioni.Thing) Like '%" + like_term_query + "%')) ORDER BY Lemmi.Thing"
                    
        print("Query SQL acquisita: "+ Query_string)

        import psycopg2 as pg2

        # questo poi come lo nascondo?
        mydb = pg2.connect(user='zogpunyhfdizcj', password='e4e8bbb8ef02572179d0ccdc1a146d4f2eba03e587525349bb4436a80b87f4ec',
                                        host='ec2-46-51-190-87.eu-west-1.compute.amazonaws.com', database='dfibp7p1uu70v7')

        #'postgres://zogpunyhfdizcj:e4e8bbb8ef02572179d0ccdc1a146d4f2eba03e587525349bb4436a80b87f4ec@ec2-46-51-190-87.eu-west-1.compute.amazonaws.com:5432/dfibp7p1uu70v7')
        #postgres://user:password@host:porta/database_name

        my_cursor = mydb.cursor()
        my_cursor.execute(Query_string)

        filtered_query_result_list = my_cursor.fetchall()
        # la chiamo così perchè sono nel caso del comando like

        # fine selected entries

        # Pagination
        # paginator = Paginator(filtered_query_result_list, 10) # Show 25 contacts per page
        # page = request.GET.get('page')
        # filtered_query_result_list = paginator.get_page(page) 

        len_result_list = len(filtered_query_result_list)
        
        #Parla alla console
        print("Query eseguita sul database con successo, %s risultati inviati al browser!" % len_result_list)


        print("************************************")

        #in questo dizionario stanno le variabili che le viste consegnano al template
        context_dict={'queryresult_key':filtered_query_result_list, 'len_result_list_key':len_result_list, 'like_term_query':like_term_query}

        return render(request, template, context_dict)


    # se il termine like è stato lasciato vuoto
    else:

        # la query rimane quella dichiarata di default
        Query_string = Query_initial_string
           
        print("Query SQL acquisita: "+ Query_string)
        

        import psycopg2 as pg2

        # questo poi come lo nascondo?
        mydb = pg2.connect(user='zogpunyhfdizcj', password='e4e8bbb8ef02572179d0ccdc1a146d4f2eba03e587525349bb4436a80b87f4ec',
                                        host='ec2-46-51-190-87.eu-west-1.compute.amazonaws.com', database='dfibp7p1uu70v7')

        #'postgres://zogpunyhfdizcj:e4e8bbb8ef02572179d0ccdc1a146d4f2eba03e587525349bb4436a80b87f4ec@ec2-46-51-190-87.eu-west-1.compute.amazonaws.com:5432/dfibp7p1uu70v7')
        #postgres://user:password@host:porta/database_name

        my_cursor = mydb.cursor()
        my_cursor.execute(Query_string)

        query_result_list = my_cursor.fetchall()
        # non scrivo filtered perchè... è come se non avessi usato il filtro

        # fine selected entries

        # Pagination
        # paginator = Paginator(query_result_list, 10) # Show 25 contacts per page
        # page = request.GET.get('page')
        # query_result_list = paginator.get_page(page)     

        len_result_list = len(query_result_list)
        
        #Parla alla console
        print("Query eseguita sul database con successo, %s risultati inviati al browser!" % len_result_list)


        print("************************************")
        


        context_dict={'queryresult_key':query_result_list, 'len_result_list_key':len_result_list, 'like_term_query':like_term_query}
        
        # print(query_result_list)

        return render(request, template, context_dict)




# def vista_ricerca_semplice(request):

#     template = "glossario.html"

#     query = request.GET.get('q') #q è variabile risultante dalla query del database

#     selected_entries = glossary_entry.objects.filter(Q(Lemma_it__icontains=query))

#     context = {'selected_entries':selected_entries}

#     #return render(request, template, context)
#     return render(request, 'glossario.html', {'selected_entries':selected_entries})









